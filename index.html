<!DOCTYPE html>

<head>
    <!-- Bootstrap -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
        integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

    <!-- d3 -->
    <script src="https://d3js.org/d3.v6.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js"></script>

    <!-- CSS-->
    <link href="styles/base.css" rel="stylesheet">
    <link href="styles/tree.css" rel="stylesheet">
    <link href="styles/table.css" rel="stylesheet">
</head>

<body>
    <h1>
        Traffic Control Dashboard
    </h1>

    <!-- <label for="file-selector">Upload a dotfile:</label> -->
    <!-- <input type="file" id="file-selector" accept=".dot">
    <div id="output"></div> -->
    <!-- <form id="newParentForm">
        <h3>Create Parent Node</h3>

        <label for="parentNode"><b>Parent node label</b></label>
        <input type="text" placeholder="Enter label" name="parentNode" required>

        <label for="childNode"><b>Child node label</b></label>
        <input type="text" placeholder="Enter label" name="childNode" required>

        <button type="submit" class="btn">Submit</button>
        <button class="btn cancel" id="closeParentForm">Close</button>
    </form> -->

    <div class="container">
        <div class="row">
            <div class="col-8" id="svg"></div>
            <div class="col-4 align-content-start">
                <label for="file-selector-1">Upload dotfiles:</label>
                <div id="file-selectors">
                    <input type="file" id="file-selector-1" accept=".dot">
                </div>
                <div class="text-center">
                    <button id="uploadDotfileButton" onclick="addInputDiv()">Add input file</button>
                </div>
            </div>
        </div>
    </div>
</body>

<!-- Scripts -->
<script src="scripts/parseTree.js"></script>
<script src="scripts/drawTree.js"></script>
<script src="scripts/helper.js"></script>
<script src="scripts/trees.js"></script>
<script>

    // ************** Event listeners	 *****************
    const inputFileDiv = document.getElementById("file-selector-1")
    inputFileDiv.addEventListener('input', handleDotfileUpload)
    // const parentNodeForm = document.getElementById("newParentForm")
    // parentNodeForm.addEventListener('submit', addNewRoot)
    // const closeParentForm = document.getElementById("closeParentForm")
    // closeParentForm.addEventListener('submit', closeForm)

    // ************** Form open close	 *****************
    function openForm() {
        document.getElementById("newParentForm").style.display = "block";
    }

    function closeForm() {
        document.getElementById("newParentForm").style.display = "none";
    }

    // ************** Graph editors and extractor *****************
    function getHeadLabel(edges) {
        let possibleHeads = Object.keys(edges)
        for (edge in edges) {
            for (child of edges[edge]) {
                var index = possibleHeads.indexOf(child);
                if (index > -1) {
                    possibleHeads.splice(index, 1);
                }
            }
        }
        return possibleHeads[0]
    }

    function updateParent(node, newParent) {
        for (parent in edges) {
            if (node in edges[parent]) {
                let i = edges[parent].indexOf(node)
                delete edges[parent][i]
            }
        }
        edges[newParent].push(node)
    }

    function addNewRoot(e) {
        e.preventDefault()
        let nodeLabel = parentNodeForm.elements[0].value;
        let childLabel = parentNodeForm.elements[1].value;

        let IDs = Object.keys(nodes).map(x => +x)
        let maxID = IDs.reduce(function (a, b) {
            return Math.max(a, b);
        });

        nodes[maxID + 1] = nodeLabel
        nodes[maxID + 2] = childLabel

        edges[maxID + 1] = [head, maxID + 2]

        head = maxID + 1

        updateTree()
    }

    function getNodePositions(nodes, edges, source, parentX, parentY, left) {
        nodes[source]['x'] = left ? parentX - 60 : parentX + 60
        nodes[source]['y'] = parentY + 150
        nodes[source]["depth"] = nodes[source]["y"] / 150
        nodes[source]['shown'] = true
        if (edges[source] == undefined) {
            edges[source] = []
        }
        else if (edges[source].length == 1) {
            [nodes,edges] = getNodePositions(nodes, edges, edges[source][0], nodes[source]['x'], nodes[source]['y'], true)
        } else {
            [nodes,edges] =getNodePositions(nodes, edges, edges[source][0], nodes[source]['x'], nodes[source]['y'], true)
            [nodes,edges] =getNodePositions(nodes, edges, edges[source][1], nodes[source]['x'], nodes[source]['y'], false)
        }
        return [nodes, edges]
    }

    function graphToHierarchyWithPositions(nodes, edges, head, parentX, parentY, left) {
        let result = {}

        result["label"] = nodes[head]
        result["x"] = left ? parentX - 10 : parentX + 10
        result["y"] = parentY + 150
        if (edges[head] == undefined) {
            result["children"] = []
        } else if (edges[head].length == 1) {
            result["children"] = [graphToTreeWithPositions(nodes, edges, edges[head][0], result["x"], result["y"], true)]
        } else {
            result["children"] = [graphToTreeWithPositions(nodes, edges, edges[head][0], result["x"], result["y"], true), graphToTreeWithPositions(nodes, edges, edges[head][1], result["x"], result["y"], true)]
        }
        return result
    }

    // ************** D3 Operations *****************
    function collapse(source) {
        nodes[source].shown = false
        if (edges[source] == undefined) {
            return
        }
        if (edges[source].length == 1) {
            collapse(edges[source][0])
        } else {
            collapse(edges[source][0])
            collapse(edges[source][1])
        }
    }

    function showChildren(source) {
        if (edges[source].length == 1) {
            nodes[edges[source][0]]['shown'] = true
        } else {
            nodes[edges[source][0]]['shown'] = true
            nodes[edges[source][1]]['shown'] = true
        }
    }

    function getLinks() {
        links = []

        for (let node in edges) {
            for (let i = 0; i < edges[node].length; i++) {
                if (nodes[edges[node][i]].shown) {
                    links.push({ "source": nodes[node], "target": nodes[edges[node][i]] })
                }
            }
        }
        return links
    }

    function handleMouseClick(d, field) {
        //Remove previous input boxes
        let toRemove = document.getElementsByClassName("overlayText")[0]
        if (toRemove != undefined) {
            toRemove.parentNode.removeChild(toRemove);
        }

        //Get coordinates
        var rect = this.getBoundingClientRect()
        var scrollTop = (window.pageYOffset !== undefined) ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
        var y = rect.y + scrollTop

        //Set up input over the svg
        var input = document.createElement("input");
        input.type = "text";
        input.className = "overlayText"
        input.style.zIndex = 2
        input.style.position = "absolute"
        input.style.left = rect.x + 'px'
        input.style.top = y + 'px'
        input.style.width = rect.width + 'px'
        input.style.height = rect.height + 'px'
        input.style.fontSize = 8 + 'px'
        input.value = d
        document.body.appendChild(input);
    }

    function handleMouseOver(d, field) {
        d3.select(this).style('fill', 'darkOrange');
    }

    function handleMouseOut(d, field) {
        d3.select(this).style('fill', 'black');
    }

    function mergeTrees(nodes1, nodes2, edges1, edges2, head1, target, head2) {
        //Sanity checks
        if (!(target in Object.keys(nodes1))) {
            alert("Target is not in the destination tree")
            return
        }

        // Get new (non overlapping) IDs for the second tree
        var newNodeIDs = {}
        var maxID = getNodeMaxID(nodes1)
        var nodes2Keys = Object.keys(nodes2)
        for (var i = 0; i < nodes2Keys.length; i++) {
            newNodeIDs[nodes2Keys[i]] = maxID + i + 1
        }

        //exchange nodes2 ids
        for (const [key, val] of Object.entries(nodes2)) {
            let temp = {}
            temp = Object.assign(temp, nodes2[key])
            temp["id"] = newNodeIDs[key]
            nodes2[newNodeIDs[key]] = temp
            delete nodes2[key]
        }

        for (const [key, val] of Object.entries(edges2)) {
            var changedList = edges2[key].map(x => newNodeIDs[x])
            edges2[newNodeIDs[key]] = changedList
            delete edges2[key]
        }

        head2 = newNodeIDs[head2]

        //Execute the merge
        var nodes = { ...nodes1, ...nodes2 }
        var edges = { ...edges1, ...edges2 }
        edges[target].push(head2) //Add the link from the target node to the second tree's head

        return [nodes, edges, head1]
    }

    function getNodeMaxID(nodes) {
        var keys = Object.keys(nodes)
        var asInts = keys.map(x => parseInt(x))
        return Math.max(...asInts)
    }

    instantiateSVG()
</script>

<script src="scripts/tests.js"></script>

</html>